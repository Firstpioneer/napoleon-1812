开发指导书：Winter’s Toll - 1812拿破仑战役多维视推演系统
项目代号：Winter-1812-Vis
核心架构：Single-Page Dashboard (单屏仪表盘) + Multi-Coordinated Views (多视图联动)
技术栈强制要求：D3.js (数据驱动绘图), React (状态管理), Leaflet/Mapbox (地理底座)
1. 系统数据结构规范 (Schema Definitions)
在写任何界面代码前，后端/数据组必须清洗出满足“多维度查询”的JSON数据。不要只存静态点，要存“状态”。
1.1 data_waypoints.json (用于绘制地图路径与动态箭头)
我们需要在 D3 中计算线宽，所以必须包含 troop_count。
code
JSON
[
  {
    "id": "segment_001",
    "commander": "Napoleon",     // 维度：归属 (用于分组筛选)
    "phase": "Advance",          // 维度：阶段 (进攻/撤退)
    "start_coord": [23.9, 54.9], // 涅曼河
    "end_coord": [25.3, 54.7],   // 维尔纳
    "start_date": "1812-06-24",
    "end_date": "1812-06-28",
    "troop_count_start": 422000, // 定量：线宽
    "troop_count_end": 400000,
    "temperature_avg": 20        // 定量：颜色映射
  },
  // ...必须包含Schwarzenberg等侧翼的数据
]
1.2 data_events.json (用于侧边栏与时间轴锚点)
code
JSON
[
  {
    "id": "evt_borodino",
    "title": "博罗季诺战役",
    "date": "1812-09-07",
    "coordinates": [35.8, 55.5],
    "type": "Battle",            // 类型 (Battle, Crossing, Fire)
    "casualties": 75000,
    "description": "这是战役中最血腥的一天...", // 侧边栏文字
    "media_url": "assets/img/borodino.jpg"   // 侧边栏图片
  }
]
2. 界面架构与视图划分 (View Architecture)
页面不进行跳转，严格遵循 Flux 状态流。整个页面被分为三个 View 组件，共享同一个 Parent State。
全局状态 (Store):
code
TypeScript
interface GlobalState {
  currentDateRange: [Date, Date]; // [联动核心] 时间窗口
  selectedEntity: string | null;  // [联动核心] 选中的军团 (e.g., 'Schwarzenberg')
  highlightedEvent: string | null;// [联动核心] 悬停/点击的战役ID
  isPlaying: boolean;             // 动画状态
}
视图 A：【主舞台】动态战术地图 (Tactical Map View)
职责：可视化空间分布、行军路线、地形约束。
技术实现：
底层：React-Leaflet 或 Mapbox GL JS 加载浅色/地形晕渲切片。
绘图层 (必须用D3)：在地图上覆盖一个全屏 <svg> 层（Pointer-events: none），将经纬度通过 d3.geoPath 投影转化为 SVG 坐标。
D3关键实现点：
路径生成：使用 D3 画 path，依据 data_waypoints。
视觉编码 (评分重点)：
stroke-width = d3.scaleLinear(troop_count) (严谨映射)。
stroke (颜色) = d3.scaleOrdinal(commander_type) 或 d3.scaleSequential(temperature)。
战术箭头 (Score Boost)：不要只画线。在 Path 的中间或末端，根据 Path 的角度计算 transform，绘制 SVG <polygon> 箭头。
视图 B：【控制器】气候与损耗时间轴 (Context Timeline)
职责：筛选器（Filter）、提供时间上下文、展示温度/伤亡相关性。
技术实现：纯 D3.js SVG 图表。
上层：温度折线图（负值区域填充冰蓝色）。
下层：双轴面积图（Total Survivors）。
交互层：d3.brushX (必做)。
联动逻辑：
当 d3.event.selection 变化时 -> 更新 GlobalState.currentDateRange -> 触发视图A重绘。
视图 C：【详情板】智能多媒体侧边栏 (Semantic Side-Panel)
职责：承载“叙事”、“图文”和“数值对比”。
布局：固定在屏幕右侧（Width: 300px），悬浮于地图之上。
内容动态化：
默认态：显示当前时间段的总体战损（数字跳动）。
激活态：当 View A 中的“Borodino”节点被点击，侧边栏滑出战役详情（图片+描述）。
对比态：当在图例中勾选“Schwarzenberg”，显示该军团与主力的存活率 Bar Chart 对比。
3. 核心交互与联动逻辑 (Integration Logic)
这一部分是你们拿高分的关键，代码中必须有明确的 Event Handler。
场景一：时间联动 (The "Brush & Filter" Interaction)
动作：用户在 视图B 用鼠标刷选 Oct 15 - Nov 15（大撤退初期）。
代码流转：
Brush 触发 onChange。
React State 更新 dateRange。
视图 A 响应：
D3 Selection 根据 data.filter(d => d.date within dateRange) 重新计算 Join。
不在时间范围内的路径 -> opacity: 0.1 (Context)。
在范围内的路径 -> opacity: 1, 且播放 stroke-dashoffset 流动动画。
视图 C 响应：
统计面板计算该月战损：“此月减员 80,000人，主要死因：冻死”。
场景二：实体联动 (The "Structure Comparison" Interaction)
动作：用户在 视图C 点击“对比侧翼”按钮。
代码流转：
State 更新 selectedEntity = 'Schwarzenberg'。
视图 A 响应：
地图镜头（ViewPort）平滑移动到欧洲南部（奥地利军团位置）。
拿破仑的主力线变灰，高亮施瓦岑贝格的蓝色箭头。
视图 B 响应：
时间轴上的兵力面积图叠加一层半透明区域，显示施瓦岑贝格的兵力占比。
4. 可视编码开发字典 (Visual Encoding Dictionary)
在PPT和开发注释中必须严格遵守，以证明设计的严谨性。
视觉通道 (Visual Channel)	数据维度 (Data Attribute)	D3 实现方法 (D3 Implementation)	设计解释 (Rationale)
位置 (X,Y)	地理坐标	d3.geoPath().projection()	展现行军路线受真实地形影响
宽度 (Size)	剩余兵力	d3.scaleSqrt().domain([0, 422k]).range([1, 40])	Sqrt 比例尺符合人眼对面积的感知，体现流失感
色相 (Hue)	进军方向	Adv: 金色, Retreat: 黑色	黑/金对比，模拟帝国辉煌到焦土毁灭的过程
颜色饱和度 (Saturation)	温度 (View B)	d3.scaleSequential(interpolateBlues)	越冷颜色越深，强调严寒是致命因素
纹理 (Texture)	撤退混乱度	SVG stroke-dasharray 虚线	用断断续续的虚线表示撤退时建制被打散
5. 开发流程Checklist (Roadmap)
Day 1-2: 基础设施搭建
初始化 React 项目。
配置 Leaflet/Mapbox，确保底图加载成功（选一套灰白色调的地图样式）。
数据清洗：把文本和Excel转换成 JSON。
Day 3-5: 攻克 D3+地图 (View A)
这是一个技术难点：如何在地图缩放时，保证 D3 的 SVG 路径跟着缩放且对齐？
方案：监听 Leaflet 的 zoomend 事件，重置 D3 的 projection 转换。
Day 6: 时间轴开发 (View B)
画出带有负温填充区的折线图。
实现 Brush 功能，打印 log 确保能拿到选中的日期。
Day 7: 状态联动与侧边栏 (View C)
把 dateRange state 传给 View A。
编写过滤器逻辑，让地图随时间动起来。
开发侧边栏组件，写死一些图片和文字内容做 Demo。
Day 8: 细节打磨
增加 Tooltip (D3 tip)。
增加战术箭头的三角头 (Arrowheads)。
检查 PPT 所需的截图是否美观。
6. 特殊技术难点预警
箭头的动态方向：
使用 D3 绘制箭头时，很难让箭头头部随线条自动旋转。
解决方案：使用 SVG 的 marker-end 属性，或者在 JS 里计算 path 最后一段切线的角度 Math.atan2(dy, dx)，然后 transform: rotate(...)。
性能问题：
如果有几千个 DOM 元素，Brushing 会卡顿。
解决方案：尽量合并 Path，或者使用 React useMemo 避免不必要的重渲染。